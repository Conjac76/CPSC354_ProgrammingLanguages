# Assignment 2: Calculator Specification

## Overview

The goal of this project is to implement a calculator in Python using a context-free grammar (CFG) for parsing mathematical expressions. The grammar is defined in `grammar.lark` and the main Python file `calculator_cfg.py` contains the logic for parsing and evaluating expressions.

The calculator supports the following operations:
- Addition (`+`)
- Subtraction (`-`)
- Multiplication (`*`)
- Division (`/`)
- Exponentiation (`^`)
- Negation (`-`)
- Logarithmic operations (`log base`)

The expression is parsed into an Abstract Syntax Tree (AST), which is then recursively evaluated to produce the result.

## Grammar (`grammar.lark`)

The grammar is defined in the file `grammar.lark` and specifies the rules for parsing mathematical expressions:

### Rules:
1. **Start Rule:**
   - `?start: exp`
   - This defines the starting point for the grammar. It represents an expression.

2. **Expression Rule:**
   - `?exp: term "+" term -> plus`
   - `exp` is composed of terms that are added or subtracted.

3. **Term Rule:**
   - `?term: factor "*" factor -> times`
   - `term` is composed of factors that are multiplied or divided.

4. **Atom Rule:**
   - `?atom: "log" atom "base" atom -> log`
   - `atom` defines logarithmic expressions with the format `log base`.
   - Atoms can also be basic factors such as numbers or expressions within parentheses.

5. **Factor Rule:**
   - `?factor: factor "^" atom -> power`
   - `factor` allows for exponentiation with right associativity.
   - Negation and parentheses are also handled here.

### Token Imports:
- `NUMBER`: Parses numbers.
- `WS`: Ignores whitespace in the input.

## Transformer Class (`CalcTransformer`)

The `CalcTransformer` class extends the `Transformer` class from Lark and is responsible for transforming the parsed input into a more manageable AST for evaluation.

### Methods:

1. **plus(self, items)**
   - Purpose: Represents an addition operation.
   - Input: Two items (operands).
   - Output: A tuple `('plus', item1, item2)` representing the addition operation.

2. **minus(self, items)**
   - Purpose: Represents a subtraction operation.
   - Input: Two items (operands).
   - Output: A tuple `('minus', item1, item2)` representing the subtraction operation.

3. **times(self, items)**
   - Purpose: Represents a multiplication operation.
   - Input: Two items (operands).
   - Output: A tuple `('times', item1, item2)` representing the multiplication operation.

4. **divide(self, items)**
   - Purpose: Represents a division operation.
   - Input: Two items (operands).
   - Output: A tuple `('divide', item1, item2)` representing the division operation.

5. **power(self, items)**
   - Purpose: Represents an exponentiation operation.
   - Input: Two items (base and exponent).
   - Output: A tuple `('power', base, exponent)` representing the power operation.

6. **neg(self, items)**
   - Purpose: Represents a negation operation.
   - Input: One item (operand).
   - Output: A tuple `('neg', item)` representing the negation of the operand.

7. **log(self, items)**
   - Purpose: Represents a logarithmic operation.
   - Input: Two items (value and base).
   - Output: A tuple `('log', value, base)` representing the logarithm operation.

8. **num(self, items)**
   - Purpose: Converts the number parsed from the input into a float.
   - Input: One item (number).
   - Output: A tuple `('num', float(number))` representing the numerical value.

## Evaluation Function (`evaluate`)

The `evaluate` function recursively processes the AST generated by the `CalcTransformer` to compute the final result of the expression.

### Logic:
- The function takes in an `ast` (Abstract Syntax Tree).
- Based on the root operation of the AST (e.g., `plus`, `times`, etc.), it recursively evaluates the operands and performs the required arithmetic.

### Supported Operations:

1. **plus**
   - Purpose: Adds two evaluated operands.
   - Example: `evaluate(('plus', left_operand, right_operand))` results in `left_operand + right_operand`.

2. **minus**
   - Purpose: Subtracts two evaluated operands.
   - Example: `evaluate(('minus', left_operand, right_operand))` results in `left_operand - right_operand`.

3. **times**
   - Purpose: Multiplies two evaluated operands.
   - Example: `evaluate(('times', left_operand, right_operand))` results in `left_operand * right_operand`.

4. **divide**
   - Purpose: Divides two evaluated operands.
   - Example: `evaluate(('divide', left_operand, right_operand))` results in `left_operand / right_operand`.

5. **power**
   - Purpose: Exponentiation of two evaluated operands.
   - Example: `evaluate(('power', base, exponent))` results in `base ** exponent`.

6. **neg**
   - Purpose: Negates the evaluated operand.
   - Example: `evaluate(('neg', operand))` results in `-operand`.

7. **log**
   - Purpose: Computes the logarithm of the evaluated operand with a given base.
   - Example: `evaluate(('log', value, base))` results in `math.log(value, base)`.

8. **num**
   - Purpose: Returns the numerical value as a float.
   - Example: `evaluate(('num', value))` results in `value`.

## Main Program Flow (`calculator_cfg.py`)

1. The grammar is loaded from the `grammar.lark` file.
2. A `Lark` parser is created using the loaded grammar and the `lalr` parser type.
3. The input expression is parsed using the Lark parser, generating a parse tree.
4. The parse tree is transformed into an AST using the `CalcTransformer`.
5. The AST is passed to the `evaluate` function, which recursively evaluates the expression.
6. The final result is printed to the console.

## Conclusion

This calculator program uses Lark's parsing capabilities to generate an AST from mathematical expressions, which is then recursively evaluated using Python functions. The design ensures that operator precedence and associativity are respected according to the rules defined in the grammar.
