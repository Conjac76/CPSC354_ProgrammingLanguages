\documentclass{article}
\usepackage{amsmath}
\usepackage{forest}
\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }

\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  escapeinside={(*@}{@*)} % Custom escape settings to handle special chars
}

\newtheoremstyle{theorem}
  {\topsep}   % ABOVESPACE
  {\topsep}   % BELOWSPACE
  {\itshape\/}  % BODYFONT
  {0pt}       % INDENT (empty value is the same as 0pt)
  {\bfseries} % HEADFONT
  {.}         % HEADPUNCT
  {5pt plus 1pt minus 1pt} % HEADSPACE
  {}          % CUSTOM-HEAD-SPEC
\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Report}
\author{Connor Jacobs \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
This report will contain a summary of my learning progress throughout the course, so far including: lean proofs
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

This report will document my learning through the course. The content will be structured week by week, with sections on mathematical notes, homework solutions, and personal reflections on the topics discussed.

\section{Week by Week}\label{homework}

\subsection{Week 1}

\subsubsection*{Mathematical Proof}

Proving that $37x + q = 37x + q$ demonstrates the reflexivity property of equality. Reflexivity states that any mathematical expression is equal to itself. In this case, the expression $37x + q$ is compared to itself, and it is immediately clear by the reflexivity of equality that this statement is true.

\subsubsection*{Proof in Lean}

In Lean, the theorem $37x + q = 37x + q$ is proven using the `rfl` tactic. The `rfl` tactic in Lean stands for "reflexivity" and handles proofs of the form $X = X$. When `rfl` is executed, Lean verifies that both sides of the equation are equal and the proof is complete.

The command to execute in Lean is simply:
\begin{verbatim}
rfl
\end{verbatim}

\subsubsection*{Connection Between Lean and Mathematics}

In mathematics, we rely on the axiom of reflexivity to assert that $37x + q = 37x + q$. Likewise, in Lean, the `rfl` tactic automates this process by invoking the same principle. The use of `rfl` in Lean serves as a direct representation of reflexivity in mathematical logic, providing an automated and formalized way to conclude that an expression is equal to itself.

Thus, both in Lean and in traditional mathematics, the proof of $37x + q = 37x + q$ is an application of the same fundamental concept: the reflexivity of equality.

\subsubsection*{Answers to Levels 5-8}

\subsubsection*{Level 5}

\begin{verbatim}
rw [add_zero]
rw [add_zero]
rfl
\end{verbatim}

\subsubsection*{Level 6}

\begin{verbatim}
rw [add_zero c]
rw [add_zero b]
rfl
\end{verbatim}

\subsubsection*{Level 7}

\begin{verbatim}
rw [one_eq_succ_zero]
rw [add_succ]
rw [add_zero]
rfl
\end{verbatim}

\subsubsection*{Level 8}

\begin{verbatim}
rw [two_eq_succ_one]
rw [one_eq_succ_zero]
rw [four_eq_succ_three]
rw [three_eq_succ_two]
rw [two_eq_succ_one]
rw [one_eq_succ_zero]
rw [add_succ]
rw [add_succ]
rw [add_zero]
rfl
\end{verbatim}

\subsection{Week 2}

\subsubsection*{Mathematical Proofs and Lean Implementation}

\textbf{Theorem (Associativity of Addition):} For all natural numbers $a$, $b$, and $c$, the addition operation is associative: $(a + b) + c = a + (b + c)$.

\textit{Proof:} By induction on $c$:

\begin{itemize}
    \item \textbf{Base Case:} When $c = 0$, we have:
    \[
    (a + b) + 0 = a + (b + 0)
    \]
    Using the property addition with zero, this simplifies to:
    \[
    a + b = a + b
    \]
    This equality holds by the reflexivity of equality

    \item \textbf{Inductive Step:} Assume the hypothesis holds for some $d$
    \[
    (a + b) + d = a + (b + d)
    \]
    We must prove $c = \text{succ}(d)$:
    \[
    (a + b) + \text{succ}(d) = a + (b + \text{succ}(d))
    \]
    this can be rewritten as:
    \[
    \text{succ}((a + b) + d) = \text{succ}(a + (b + d))
    \]
    By the inductive hypothesis, we know $(a + b) + d = a + (b + d)$, so:
    \[
    \text{succ}((a + b) + d) = \text{succ}(a + (b + d))
    \]
    This completes the proof of associativity.
\end{itemize}

\textbf{Connection to Lean Proof of Associativity of Addition:}

The Lean proof is the same structure of the mathematical proof:

\begin{verbatim}
induction c with d hd
-- Base case
rw [add_zero]  -- Simplifies (a + b) + 0 to a + b using add_zero
rw [add_zero]  -- Simplifies a + (b + 0) to a + b using add_zero
rfl            -- Reflexivity: confirms a + b = a + b
-- Inductive step
rw [add_succ]  -- Rewrites (a + b) + succ d as succ ((a + b) + d)
rw [hd]        -- Applies the inductive hypothesis: (a + b) + d = a + (b + d)
rw [add_succ]  -- Rewrites a + (b + succ d) as succ (a + (b + d))
rw [add_succ]  -- Confirms that the expressions on both sides match
rfl            -- Reflexivity: confirms succ (a + (b + d)) = succ (a + (b + d))
\end{verbatim}

\textbf{Explanation:}

\begin{itemize}
  \item \textbf{Base Case in Lean:}
  \begin{itemize}
      \item \texttt{rw [add\_zero]} is used twice to simplify both sides of the equation to $a + b$, directly corresponding to the mathematical step where $a + b = a + b$ is shown by reflexivity.
      \item \texttt{rfl} is then used to verify
  \end{itemize}

  \item \textbf{Inductive Step in Lean:}
  \begin{itemize}
      \item \texttt{rw [add\_succ]} rewrites the expression using the definition of addition with the successor, corresponding to the mathematical step where we transition from $(a + b) + \text{succ}(d)$ to $\text{succ}((a + b) + d)$.
      \item \texttt{rw [hd]} applies the inductive hypothesis, mirroring the assumption that $(a + b) + d = a + (b + d)$.
  \end{itemize}
\end{itemize}

\subsubsection*{Week 2 questions}

\textbf{Question:} Can Lean be used to verify complex operations in critical systems such as financial transactions or autonomous vehicles? What are the limitations of its use in such a high stakes environment?

\subsection{Week 3}

\textbf{Discord Name:} connorjacobs

\textbf{Discord Posting:} In my research, I took a look at how advancements in programming languages have balanced performance, safety, and ease of use, focusing on Rust and TypeScript. Rustâ€™s ownership model enforces memory safety by controlling how data is accessed and managed, preventing issues like memory leaks and race conditions without garbage collection. In contrast, TypeScript enhances JavaScript by introducing type checking, catching type errors early, and improving overall code reliability.

\textbf{Link to ReadMe:} \\
\href{https://github.com/Conjac76/WeekThree354/blob/main/README.md}{https://github.com/Conjac76/WeekThree354/blob/main/README.md}

\textbf{Links to two reviews I voted for:} \\
\href{https://github.com/tannerplatt/TannerHW3_354/blob/main/README.md}{https://github.com/tannerplatt/TannerHW3\_354/blob/main/README.md} \\
\href{https://github.com/tyedwards37/Using-LLM-for-Literature-Review}{https://github.com/tyedwards37/Using-LLM-for-Literature-Review}


\subsection{Week 4}

\subsection*{Derivation Trees}

Below are the derivation trees for the given strings using the provided context-free grammar:

\subsubsection*{1. Derivation Tree for \(2+1\)}

\begin{forest}
  [Exp
    [Exp ['2']]
    [\texttt{'+'}]
    [Exp1
      [Exp2 ['1']]
    ]
  ]
\end{forest}

\subsubsection*{2. Derivation Tree for \(1+2*3\)}

\begin{forest}
  [Exp
    [Exp ['1']]
    [\texttt{'+'}]
    [Exp1
      [Exp1 
        [Exp2 ['2']]
      ]
      [\texttt{'*'}]
      [Exp2 ['3']]
    ]
  ]
\end{forest}

\subsubsection*{3. Derivation Tree for \(1+(2*3)\)}

\begin{forest}
  [Exp
    [Exp ['1']]
    [\texttt{'+'}]
    [Exp1
      [Exp2
        [\texttt{'('}]
        [Exp
          [Exp1
            [Exp1
              [Exp2 ['2']]
            ]
            [\texttt{'*'}]
            [Exp2 ['3']]
          ]
        ]
        [\texttt{')'}]
      ]
    ]
  ]
\end{forest}

\subsubsection*{4. Derivation Tree for \((1+2)*3\)}

\begin{forest}
  [Exp
    [Exp1
      [Exp1 
        [Exp2
          [\texttt{'('}]
          [Exp
            [Exp1
              [Exp
                [Exp1
                  [Exp2 ['1']]
                ]
              ]
              [\texttt{'+'}]
              [Exp1
                [Exp2 ['2']]
              ]
            ]
          ]
          [\texttt{')'}]
        ]
      ]
      [\texttt{'*'}]
      [Exp2 ['3']]
    ]
  ]
\end{forest}

\subsubsection*{5. Derivation Tree for \(1+2*3+4*5+6\)}

\begin{forest}
  [Exp
    [Exp
      [Exp 
        [Exp1
          [Exp2 ['1']]
        ]
      ]
      [\texttt{'+'}]
      [Exp1
        [Exp1
          [Exp1 
            [Exp2 ['2']]
          ]
          [\texttt{'*'}]
          [Exp2 ['3']]
        ]
      ]
    ]
    [\texttt{'+'}]
    [Exp1
      [Exp1
        [Exp1 
          [Exp2 ['4']]
        ]
        [\texttt{'*'}]
        [Exp2 ['5']]
      ]
      [\texttt{'+'}]
      [Exp1
        [Exp2 ['6']]
      ]
    ]
  ]
\end{forest}

\subsection{Week 5}

\section*{Solutions to Levels 1-8 (Lean Syntax)}

\subsection*{Level 1}
\texttt{exact todo\_list}

\subsection*{Level 2}
\texttt{exact and\_intro p s}

\subsection*{Level 3}
\texttt{exact and\_intro (and\_intro a i) (and\_intro o u)}

\subsection*{Level 4}
\begin{verbatim}
have p := and_left vm
have p := vm.left
exact p
\end{verbatim}

\subsection*{Level 5}
\texttt{exact h.right}

\subsection*{Level 6}
\texttt{exact and\_intro (and\_left h1) (and\_right h2)}

\subsection*{Level 7}
\begin{verbatim}
have h1 := h.left
have h2 := h1.right
have h3 := h2.left
have h4 := h3.left
have h5 := h4.right
exact h5
\end{verbatim}

\subsection*{Level 8}
\begin{verbatim}
have h1 := h.left
have h2 := h1.left
have h3 := h1.right
have h4 := h.right.right.left
have h5 := h4.left
exact and_intro h3 (and_intro h5 (and_intro h2.left h2.right))
\end{verbatim}

\subsection*{Level 8: Proof in Mathematical Logic}

If $P \land (Q \land R) \land ((S \land T) \land (U \land V))$, then $P \land (S \land U \land V)$.

\begin{align*}
(1) &\quad P \land (Q \land R) \land ((S \land T) \land (U \land V)) \quad & \text{assumption} \\
(2) &\quad P \land (Q \land R) \quad & \text{and\_left (1)} \\
(3) &\quad P \quad & \text{and\_left (2)} \\
(4) &\quad (S \land T) \land (U \land V) \quad & \text{and\_right (1)} \\
(5) &\quad S \land T \quad & \text{and\_left (4)} \\
(6) &\quad U \land V \quad & \text{and\_right (4)} \\
(7) &\quad S \quad & \text{and\_left (5)} \\
(8) &\quad U \quad & \text{and\_left (6)} \\
(9) &\quad V \quad & \text{and\_right (6)} \\
(10) &\quad P \land (S \land U \land V) \quad & \text{and\_intro (3) (7) (8) (9)}
\end{align*}


\subsection{Week 6}


\subsubsection*{Level 1}
\begin{verbatim}
have c : C := bakery_service p
exact c
\end{verbatim}

\subsubsection*{Level 2}
\begin{verbatim}
exact /lambda h : C -> h
\end{verbatim}

\subsubsection*{Level 3}
\begin{verbatim}
exact /lamba h : I ^ S -> âŸ¨h.right, h.leftâŸ©
\end{verbatim}

\subsubsection*{Level 4}
\begin{verbatim}
exact /lamba c : C -> h2 (h1 c)
\end{verbatim}

\subsubsection*{Level 5}
\begin{verbatim}
have q : Q := h1 p
have t : T := h3 q
have u : U := h5 t
exact u
\end{verbatim}

\subsubsection*{Level 6}
\begin{verbatim}
exact fun c : C => fun d : D => h âŸ¨c, dâŸ©
\end{verbatim}

\subsubsection*{Level 7}
\begin{verbatim}
exact fun cd : C ^ D => h cd.left cd.right
\end{verbatim}

\subsubsection*{Level 8}
\begin{verbatim}
exact fun s : S => âŸ¨h.left s, h.right sâŸ©
\end{verbatim}

\subsubsection*{Level 9}
\begin{verbatim}
exact fun r : R => âŸ¨fun s : S => r, fun ns : Â¬S => râŸ©
\end{verbatim}

\subsubsection*{Question:}
Lambda calculus serves as a foundational framework for computation and formal logic. How can lambda calculus be used to reason about mnore advanced concepts, such as polymorphism?


\section{Lessons from the Assignments}

\subsection{Key Lessons}

The assignments taught the foundational properties in mathematics, such as reflexivity, commutativity, and associativity, and their implementation in Lean. Lean's tactics like `rfl` and `rw` simplify proofs by automating logical steps, making it easier to verify mathematical statements. 

\section{Conclusion}\label{conclusion}

I have learned the connection between mathematical proofs and Lean verification. 

\begin{thebibliography}{99}
\bibitem[BLA], Author, Title, Publisher, Year.
\end{thebibliography}
\end{document}
